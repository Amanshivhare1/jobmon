import os
import re
import pandas as pd

def extract_dtsx_from_bat(bat_file):
    dtsx_files = []
    try:
        with open(bat_file, "r") as f:
            content = f.read()
            matches = re.findall(r'[\w\-. ]+\.dtsx', content, flags=re.IGNORECASE)
            dtsx_files.extend(matches)
    except Exception as e:
        print(f"Error reading {bat_file}: {e}")
    return dtsx_files


def get_dtsx_from_path(path):
    dtsx_files = []

    if os.path.isfile(path):
        if path.lower().endswith(".dtsx"):
            dtsx_files.append(os.path.basename(path))
        elif path.lower().endswith(".bat"):
            dtsx_files.extend(extract_dtsx_from_bat(path))

    elif os.path.isdir(path):
        for file in os.listdir(path):
            if file.lower().endswith(".dtsx"):
                dtsx_files.append(file)
-------------------------------
import os
import shutil

# File with remote paths
paths_file = "paths.txt"

# Local directory to copy to
local_root = r"C:\local_copy\"  # Change to your local path

# Ensure local root exists
os.makedirs(local_root, exist_ok=True)

with open(paths_file, "r") as file:
    for line in file:
        remote_path = line.strip()
        if not remote_path:
            continue

        # Extract folder/file name from remote path
        folder_name = os.path.basename(remote_path.rstrip("\\/"))

        # Destination path on local
        dest_path = os.path.join(local_root, folder_name)

        try:
            # Copy folder or file
            if os.path.isdir(remote_path):
                shutil.copytree(remote_path, dest_path, dirs_exist_ok=True)
            elif os.path.isfile(remote_path):
                shutil.copy2(remote_path, dest_path)
            else:
                print(f"‚ö† Path not found: {remote_path}")
        except Exception as e:
            print(f"‚ùå Failed to copy {remote_path} -> {dest_path}: {e}")

print("‚úÖ All paths processed.")


    return dtsx_files


def process_excel(input_excel, output_excel):
    df = pd.read_excel(input_excel)

    # Assuming column name is "Path"
    df["DTSX_Files"] = df["Path"].apply(
        lambda p: "; ".join(get_dtsx_from_path(p))
    )

    df.to_excel(output_excel, index=False)
    print(f"‚úÖ Processed Excel saved as: {output_excel}")


# Example usage
process_excel("input.xlsx", "output_with_dtsx.xlsx")




----------------------------------------------------------

import paramiko

def get_remote_disks(host, user, password):
    command = "df -h --output=target,size,used,avail,pcent | tail -n +2"
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    ssh.connect(host, username=user, password=password)
    stdin, stdout, stderr = ssh.exec_command(command)
    output = stdout.read().decode().strip()
    ssh.close()

    print(f"\nServer: {host}")
    print(f"{'Mount':<15} {'Total':>10} {'Used':>10} {'Avail':>10} {'Use%':>6}")
    print("-" * 55)
    for line in output.splitlines():
        print(line)

if __name__ == "__main__":
    get_remote_disks("192.168.1.10", "ec2-user", "mypassword")

--------------------------------
for /f "skip=1 tokens=1,2,3" %i in ('wmic logicaldisk get Name,Size,FreeSpace') do @if not "%i"=="" @set /a totalGB=%j/1073741824 & @set /a freeGB=%k/1073741824 & @echo Drive: %i  Total: !totalGB! GB  Free: !freeGB! GB

--------------------------------
import wmi

def get_windows_disk_space(host, user, password):
    conn = wmi.WMI(computer=host, user=user, password=password)
    print(f"\nDisk space for {host}:")
    print(f"{'Drive':<6} {'Total(GB)':>10} {'Free(GB)':>10}")
    print("-" * 30)
    for disk in conn.Win32_LogicalDisk(DriveType=3):  # DriveType=3 is local disks
        total_gb = int(disk.Size) // (2**30)
        free_gb = int(disk.FreeSpace) // (2**30)
        print(f"{disk.DeviceID:<6} {total_gb:>10} {free_gb:>10}")

if __name__ == "__main__":
    host = input("Enter Windows server IP/hostname: ")
    user = input("Username (DOMAIN\\User): ")
    password = input("Password: ")
    get_windows_disk_space(host, user, password)


-------------------------------------
# Define your root path (use raw string to handle backslashes)
root = r"a\b\c\d\"

# Input and output file names
input_file = "paths.txt"
output_file = "cleaned_paths.txt"

with open(input_file, "r") as infile, open(output_file, "w") as outfile:
    for line in infile:
        path = line.strip()
        if not path:
            continue  # skip empty lines

        # Ensure consistent backslashes
        path = path.replace("/", "\\")
        root_norm = root.replace("/", "\\")

        if root_norm in path:
            # Remove the root part
            remaining = path[len(root_norm):]

            # Get the next folder after the root
            parts = remaining.split("\\")
            next_folder = parts[0] if parts else ""

            if next_folder:
                # Build the cleaned path up to that folder
                cleaned_path = root_norm + next_folder + "\\"
                outfile.write(cleaned_path + "\n")
        else:
            # Skip if path doesn't contain the root
            continue

print(f"‚úÖ Cleaned paths saved to {output_file}")
----------------------------

import os
import shutil

# File with remote paths
paths_file = "paths.txt"

# Local directory to copy to
local_root = r"C:\local_copy\"  # Change to your local path

# Ensure local root exists
os.makedirs(local_root, exist_ok=True)

with open(paths_file, "r") as file:
    for line in file:
        remote_path = line.strip()
        if not remote_path:
            continue

        # Extract folder/file name from remote path
        folder_name = os.path.basename(remote_path.rstrip("\\/"))

        # Destination path on local
        dest_path = os.path.join(local_root, folder_name)

        try:
            # Copy folder or file
            if os.path.isdir(remote_path):
                shutil.copytree(remote_path, dest_path, dirs_exist_ok=True)
            elif os.path.isfile(remote_path):
                shutil.copy2(remote_path, dest_path)
            else:
                print(f"‚ö† Path not found: {remote_path}")
        except Exception as e:
            print(f"‚ùå Failed to copy {remote_path} -> {dest_path}: {e}")

print("‚úÖ All paths processed.")

----------------------------------

import os
import re

# CONFIG
local_root = r"C:\local_copy"  # change to your local folder

# Regex: password with optional spaces around '='
pattern = re.compile(r'(password\s*=\s*)(\S+)', re.IGNORECASE)

for dirpath, dirnames, filenames in os.walk(local_root):
    for fname in filenames:
        file_path = os.path.join(dirpath, fname)
        try:
            # Read file as text
            with open(file_path, 'r', encoding='utf-8') as f:
                text = f.read()
        except UnicodeDecodeError:
            try:
                with open(file_path, 'r', encoding='latin-1') as f:
                    text = f.read()
            except:
                continue  # skip binary/unreadable files

        # Replace passwords
        new_text, count = pattern.subn(lambda m: m.group(1) + '*' * len(m.group(2)), text)

        # Write back if changes were made
        if count > 0:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(new_text)

----------------
import os
import re

# Root folder to scan
local_root = r"C:\local_copy"  # change this to your folder path

# Regex: matches 'password' (case-insensitive), optional spaces around '=', 
# then captures everything until space or ';'
pattern = re.compile(r'(password\s*=\s*)([^ ;]+)', re.IGNORECASE)

for dirpath, _, filenames in os.walk(local_root):
    for fname in filenames:
        file_path = os.path.join(dirpath, fname)

        # Try to open the file safely as text
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
        except UnicodeDecodeError:
            try:
                with open(file_path, 'r', encoding='latin-1') as f:
                    content = f.read()
            except:
                continue  # skip binary/unreadable files

        # Replace password value with ***
        new_content, count = pattern.subn(r'\1***', content)

        if count > 0:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(new_content)
----------------
import os

def get_folder_size(path):
    total_size = 0
    for dirpath, dirnames, filenames in os.walk(path):
        for f in filenames:
            try:
                fp = os.path.join(dirpath, f)
                if not os.path.islink(fp):
                    total_size += os.path.getsize(fp)
            except (FileNotFoundError, PermissionError):
                continue
    return total_size

if __name__ == "__main__":
    network_path = r"\\server\share\folder"  # üîπ change to your path
    size_bytes = get_folder_size(network_path)
    size_gb = size_bytes / (1024 ** 3)
    size_mb = size_bytes / (1024 ** 2)

    print(f"üìÅ Folder: {network_path}")
    print(f"üíæ Total Size: {size_gb:.2f} GB ({size_mb:.2f} MB)")
---------------------------
import wmi
import csv
import os
import win32api

# --- Configuration ---
SERVERS_FILE = r"C:\Users\working\Wurip\ia_servers\servers.txt"
OUTPUT_FOLDER = r"C:\Users\working\Wurip\ia_server\output"

USERNAME = "your_username"
PASSWORD = "your_password"
DOMAIN = "your_domain"  # or leave "" if local account

# --- Helper function to get company name from executable ---
def get_company_name(exe_path):
    try:
        if os.path.exists(exe_path):
            info = win32api.GetFileVersionInfo(exe_path, '\\StringFileInfo\\040904b0\\CompanyName')
            return info.strip()
    except Exception:
        pass
    return "Unknown"

# --- Ensure output directory exists ---
os.makedirs(OUTPUT_FOLDER, exist_ok=True)

# --- Read server list ---
with open(SERVERS_FILE, "r") as f:
    servers = [line.strip() for line in f if line.strip()]

# --- Loop through each server ---
for server in servers:
    print(f"\nConnecting to {server}...")

    try:
        conn = wmi.WMI(
            computer=server,
            user=f"{DOMAIN}\\{USERNAME}" if DOMAIN else USERNAME,
            password=PASSWORD
        )

        results = []
        for service in conn.Win32_Service():
            exe_path = service.PathName
            if exe_path:
                exe_path = exe_path.replace('"', '').split(' ')[0]  # clean path

            company = get_company_name(exe_path) if exe_path else "Unknown"

            # Skip Microsoft Corporation services
            if company.lower().startswith("microsoft"):
                continue

            results.append({
                "ServiceName": service.Name,
                "DisplayName": service.DisplayName,
                "Status": service.State,
                "StartupType": service.StartMode,
                "Executable": exe_path,
                "Manufacturer": company
            })

        # --- Export results to CSV ---
        output_path = os.path.join(OUTPUT_FOLDER, f"{server}_Services.csv")
        with open(output_path, "w", newline="", encoding="utf-8") as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=["ServiceName", "DisplayName", "Status", "StartupType", "Executable", "Manufacturer"])
            writer.writeheader()
            writer.writerows(results)

        print(f"‚úÖ Exported services for {server} ‚Üí {output_path}")

    except Exception as e:
        print(f"‚ùå Failed to connect to {server}: {e}")
--------------------------------------------
import wmi
import csv
import os
import win32api
from concurrent.futures import ThreadPoolExecutor, as_completed
import getpass

# --- Configuration ---
SERVERS_FILE = r"C:\Users\working\Wurip\ia_servers\servers.txt"
OUTPUT_FOLDER = r"C:\Users\working\Wurip\ia_server\output"

# --- Collect 4 sets of credentials ---
CREDENTIALS = []
for i in range(1, 5):
    print(f"\nEnter credential set #{i}:")
    username = input("  Username: ").strip()
    password = getpass.getpass("  Password: ")
    domain = input("  Domain (leave blank if local): ").strip()
    CREDENTIALS.append({"username": username, "password": password, "domain": domain})

# --- Helper: get company name from EXE ---
def get_company_name(exe_path):
    try:
        if os.path.exists(exe_path):
            info = win32api.GetFileVersionInfo(exe_path, '\\StringFileInfo\\040904b0\\CompanyName')
            return info.strip()
    except Exception:
        pass
    return "Unknown"

# --- Try connecting with a given credential set ---
def try_wmi_connect(server, cred):
    try:
        conn = wmi.WMI(
            computer=server,
            user=f"{cred['domain']}\\{cred['username']}" if cred["domain"] else cred["username"],
            password=cred["password"]
        )
        # Test query to confirm success
        _ = conn.Win32_OperatingSystem()[0]
        return conn
    except Exception:
        return None

# --- Worker: process one server ---
def fetch_services(server):
    try:
        connected_cred = None
        conn = None

        # Try each credential in order
        for cred in CREDENTIALS:
            conn = try_wmi_connect(server, cred)
            if conn:
                connected_cred = cred
                break

        if not conn:
            return f"‚ùå {server}: Failed with all 4 credentials"

        # --- Collect service info ---
        results = []
        for service in conn.Win32_Service():
            exe_path = service.PathName
            if exe_path:
                exe_path = exe_path.replace('"', '').split(' ')[0]

            company = get_company_name(exe_path) if exe_path else "Unknown"

            # Skip Microsoft services
            if company.lower().startswith("microsoft"):
                continue

            results.append({
                "Server": server,
                "ServiceName": service.Name,
                "DisplayName": service.DisplayName,
                "Status": service.State,
                "StartupType": service.StartMode,
                "Executable": exe_path,
                "Manufacturer": company,
                "UsedCredential": connected_cred["username"]
            })

        # --- Export results to CSV ---
        os.makedirs(OUTPUT_FOLDER, exist_ok=True)
        output_path = os.path.join(OUTPUT_FOLDER, f"{server}_Services.csv")
        with open(output_path, "w", newline="", encoding="utf-8") as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=[
                "Server", "ServiceName", "DisplayName", "Status", "StartupType",
                "Executable", "Manufacturer", "UsedCredential"
            ])
            writer.writeheader()
            writer.writerows(results)

        return f"‚úÖ {server}: Exported {len(results)} services (used {connected_cred['username']})"

    except Exception as e:
        return f"‚ö†Ô∏è {server}: Error - {e}"

# --- Main Execution ---
def main():
    with open(SERVERS_FILE, "r") as f:
        servers = [line.strip() for line in f if line.strip()]

    print(f"\nStarting parallel scan of {len(servers)} servers...\n")

    with ThreadPoolExecutor(max_workers=5) as executor:
        futures = {executor.submit(fetch_services, server): server for server in servers}
        for future in as_completed(futures):
            print(future.result())

if __name__ == "__main__":
    main()



